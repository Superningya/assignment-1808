
v-on 事件绑定指令 简写 @
v-bind 属性绑定指令 简写 :

v-model  =>   :value="value" @input='input'
 
v-for里  数组索引是第二个参数，对象索引是第三个参数

数组更新
    Vue.set(vm.items, indexOfItem, newValue);
    vm.$set(vm.items, indexOfItem, newValue);
    vm.items.splice(indexOfItem, 1, newValue)
对象更新
    Vue.set(vm.obj, key, newValue)；
    Object.assign({}, vm.obj, newObj);

---------------
v-for和v-if同时出现是，v-for的优先级大于v-if
如果需要v-if来处理v-for的话，需要把v-if写在外层


--vue指令修饰符--
    理解事件捕获、事件冒泡、事件委托
    .stop <=> StopPropagation  .prevent =>preventDetault .capture .self .once  .passive
    v-model  .number .lazy .trim
    v-on:keyup.13
       

--computed--
计算属性缓存vs方法
    计算属性是基于它们的响应式依赖进行缓存的只在相关响应式依赖发生改变时它们才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
计算属性的setter
    两个钩子函数 get(),set()   set定义一个参数是set值

--watch--
    回调参数（newValue，oldValue）
    监听对象、数组，handle、deep参数
    监听对象属性 对象键路径必须加上引号（’obj.name’）
    通过实例方法$watch 来监听数据   vm.$watch('数据',function(){})

--filter--
   管道符：|
   过滤器定义：
	全局定义：Vue.filter('过滤器名字'，function（）｛｝)
	局部定义：filters｛'过滤器名字'：function（）｛｝｝
    过滤器的第一个参数是，要过滤的值
    过滤器的第二个参数是，过滤器的第一个参数,以此类推
    可以用在双花括号插值和 v-bind 表达式
    过滤器 可以链式调用
    过滤器参数： data | filterA (arg1,arg2)
    过滤器更像是‘一对多’的计算熟悉 vs 计算属性 一对一
    vue1.X的内置过滤器：（了解，2.x版本已经移除这些过滤器），
	Capitalize、uppercase、lowercase、currency、pluralize、debounce、limitBy、filterBy、orderBy




